{"name":"lambda","tagline":"","body":"# lambda\r\n\r\nUntyped lambda calculus implementation.\r\n\r\nFeatures:\r\n* immutable data,\r\n* eager argument evaluation and call-by-value semantics,\r\n* macros (functions with lazy evaluation and call-by-name semantics),\r\n* left-to-right associativity for applications,\r\n\t* i.e. `a b c` is equivalent to `(a b) c`\r\n* native support for N-ary functions,\r\n* tail call optimization,\r\n* single-line comments (with the `#` character),\r\n* language utilities (see below),\r\n* extra types:\r\n\t* 32 bit signed integers\r\n\t* 64 bit signed integers\r\n\t* double-precision floating point numbers\r\n\t* complex numbers (pairs of double-precision floating point numbers)\r\n\t* strings\r\n\r\nBooleans are Church-encoded.\r\n\r\nSome examples:\r\n\r\n```\r\n# identity function\r\nlambda x . x\r\n\r\n# identity function applied to itself\r\n(lambda x . x)(lambda x . x)\r\n\r\n# the easiest way to loop the interpreter\r\n(lambda x . x x)(lambda x . x x)\r\n\r\n# factorial\r\nZ lambda factorial, n .\r\n\tif (< n 1) 1 (* n (factorial (- n 1)))\r\n\r\n# fibonacci\r\nZ lambda fibonacci, i .\r\n\tif (< i 2) 1 (+ (fibonacci (- i 1)) (fibonacci (- i 2)))\r\n\r\n# a list of 4 integers: 3, 6, 2, 5\r\nlist 3 (list 6 (list 2 (list 5 nil)))\r\n\r\n# printing a list to standard output\r\nZ lambda print_list, list .\r\n\ttail list (lambda tail .\r\n\t\thead list (lambda head .\r\n\t\t\tand (print (+ head ', ')) (print_list tail)) false) (head list (lambda head .\r\n\t\t\t\tprintln head) true)\r\n\r\n# scanning a list looking for a value\r\nZ lambda search_list, list, value .\r\n\tor (head list (lambda head .\r\n\t\t= head value) false) (tail list (lambda tail .\r\n\t\t\tsearch_list tail value) false)\r\n```\r\n\r\n## Language Utilities\r\n\r\nThe following predefined terms are readily available and you can use them without defining them (descriptions in angle brackets indicate native code implementation):\r\n\r\n```\r\ntrue   = lambda x, y . x\r\nfalse  = lambda x, y . y\r\n\r\nnot  = macro a . a false true\r\nand  = macro a, b . a (lambda x . b) (lambda x . false) nil\r\nor   = macro a, b . a (lambda x . true) (lambda x . b) nil\r\nxor  = macro a, b . a (lambda x . not b) (lambda x . b) nil\r\n\r\nif  = macro condition, then, else . condition (lambda x . then) (lambda x . else) nil\r\n\r\nZ  = lambda f . (lambda x . f lambda v . x x v) (lambda x . f lambda v . x x v)\r\n\r\n=   = <value comparison>\r\n!=  = <negated value comparison>\r\n<   = <less than>\r\n<=  = <less than or equal to>\r\n>   = <greater than>\r\n>=  = <greater than or equal to>\r\n\r\n+   = <binary sum>\r\n-   = <binary subraction>\r\n*   = <multiplication>\r\n/   = <division>\r\n%   = <modulus>\r\n**  = <power>\r\n~   = <bitwise NOT>\r\n&   = <bitwise AND>\r\n|   = <bitwise OR>\r\n^   = <bitwise XOR>\r\n\r\npair    = lambda x, y, z . z x y\r\nfirst   = macro pair . pair lambda first, second . first\r\nsecond  = macro pair . pair lambda first, second . second\r\n\r\nlist  = lambda element, next, f, g . f element next\r\nnil   = lambda f, g . g false\r\nhead  = macro list, f, g . list f lambda x . g\r\ntail  = macro list, f, g . list (lambda element, next . f next) lambda x . g\r\n\r\nexit     = <terminates the interpreter using the argument as return code>\r\nthrow    = <throws the argument as an exception, terminates the program>\r\ninput    = <ignores the argument, reads a line from standard input and returns it as a string, excluding the line terminator>\r\nprint    = <prints the string argument to standard output, returns true>\r\nprintln  = <prints the string argument followed by a line terminator to standard output, returns true>\r\nerror    = <prints the string argument to standard error, returns true>\r\nerrorln  = <prints the string argument followed by a line terminator to standard error, returns true>\r\n```\r\n\r\n## Known Issues\r\n\r\nThe `=` and `!=` comparison operators don't work on booleans because they are Church-encoded.\r\n\r\nExceptions may be thrown using the `throw` term (which has native implementation) but there's no way to catch them (yet - a future release will add it).\r\n","google":"UA-36961344-8","note":"Don't delete this file! It's used internally to help with page regeneration."}